= JRuby on Rails with Glassfish gem =

=== Prerequisites ===
====JRuby 1.3.1 or newer====

I suggest you install it in /opt/jruby-1.3.1 and symlink /opt/jruby to /opt/jruby-1.3.1 for future convenience.

 # cd /opt && curl -O http://url.to/jruby-1.3.1.tar.gz
 # tar xzvf jruby-1.3.1.tar.gz
 # ln -s jruby-1.3.1 jruby

====Glassfish gem by Arun Gupta====

 $ gem i glassfish

If you install glassfish in userland (as non-root user), you should for your own convenience add ~/.gem/jruby/1.8/bin to your PATH:

You should also have JRuby in your path. If you install glassfish as root, the glassfish bin will by default be installed in the JRuby bin directory.

 $ export JRUBY_HOME=/opt/jruby 
 $ export PATH=~/.gem/jruby/1.8/bin:$JRUBY_HOME/bin:$PATH

I recommend putting something this in your .bashrc so it's set whenever you log in.

=== Configure your glassfish instance for your Rails Application ===

 $ cd /path/to/rails-app
 $ jruby -S gfrake config         # Sets up initial config/glassfish.yml

Now edit ''config/glassfish.yml' to configure the instance to your liking. For instance:

<pre name="yaml">
 environment: production
 http:
    port: 3000
    contextroot: /

 log:
    # Logging level. Log level 0 to 7. 0:OFF, 1:SEVERE, 2:WARNING, 3:INFO (default), 4:FINE, 5:FINER, 6:FINEST, 7:ALL.
    log-level: 2

 jruby-runtime-pool:
    initial: 1
    min: 1
    max: 1

 daemon:
    enable: true
    pid: tmp/pids/glassfish-production.pid
    jvm-options: -server -Xmx2500m -Xms64m -XX:PermSize=256m -XX:MaxPermSize=256m -XX:NewRatio=2 -XX:+DisableExplicitGC -Dhk2.file.directory.changeIntervalTimer=6000
</pre>

====Running the appserver====

Running your glassfish application server is very simple:
 $ jruby -S glassfish 

====Stopping the appserver====
The application is started with the Akuma wrapper, which by default exits when passed a SIGINT (2) (default value of ''kill''). For instance:
 $ kill `cat tmp/pids/glassfish-production.pid`  

===Integrating glassfish gem with Solaris Management Facility (SMF)===

In Solaris 10 and OpenSolaris, you get an excellent service management facility called SMF which you can easily configure to run your applications on startup (and much more). It can be compared with Linux' init.rd / rc.d, but is much more powerful (out of scope).

Importing an application into SMF is not so trivial for first time users, so here is a brief description.

First off you need to define a manifest. This is done with a simple XML file. Underneath you will find a manifest with support of two instances or rails applications. Modify these to your liking. I usually prefer to run applications with a non-root-user. I have not included ACLs, and tried to minimize the complexity in the example... I usually recommend placing webapplications such as rails somewhere under /var. In the example I use /var/apps, I also use i.e. /var/rails, etc, but you can place them in your home directory if you please.

<pre name="xml">
<?xml version='1.0'?>
<!DOCTYPE service_bundle SYSTEM '/usr/share/lib/xml/dtd/service_bundle.dtd.1'>
<service_bundle type='manifest' name='glassfish-gem'>
  <service name='network/glassfish-gem' type='service' version='0'>
    <dependency name='fs' grouping='require_all' restart_on='none' type='service'>
      <service_fmri value='svc:/system/filesystem/local'/>
    </dependency>
    <dependency name='net' grouping='require_all' restart_on='none' type='service'>
      <service_fmri value='svc:/network/loopback'/>
    </dependency>
    <dependent name='glassfish-gem_multi-user' restart_on='none' grouping='optional_all'>
      <service_fmri value='svc:/milestone/multi-user'/>
    </dependent>
    <exec_method name='start' type='method' exec='/opt/jruby/bin/glassfish' timeout_seconds='60' />
    <exec_method name='stop' type='method' exec=':kill' timeout_seconds='60' />
    <!-- INSTANCES -->        
    <instance name='my-railsapp_production' enabled='false'>
      <method_context working_directory='/var/apps/my-railsapp/development/my-railsapp'>
        <method_credential user='railsuser' group='daemon' />
        <method_environment>
          <envvar name="PATH" value="/opt/jruby/bin:/usr/bin:/bin" />
        </method_environment>
      </method_context>
    </instance>
    <instance name='MYRAILSAPP_ENVIRONMENT' enabled='false'>
      <method_context working_directory='/FULL/PATH/TO/MY/RAILS/APP/ENVIRONMENT'>
        <method_credential user='RUNASTHISUSER' group='RUNASTHISGROUP' />
        <method_environment>
          <envvar name="PATH" value="/PATH/TO/JRUBY/bin:/usr/bin:/bin" />
        </method_environment>
      </method_context>
    </instance>
  </service>
</service_bundle>
</pre>

====Import the manifest into SMF====
 $ pfexec svccfg validate config/glassfish-gem.smf.xml
 $ pfexec svccfg import config/glassfish-gem.smf.xml

====Start your appserver====
 $ pfexec svcadm enable glassfish-gem:my-railsapp_production

To verify your application is started, use ''svcs''
 $ pfexec svcs

You should see something like:
 online         Jun_30   svc:/network/glassfish-gem:my-railsapp_production

If it fails to start, it will say ''offline*'' or ''maintenance'' instead of ''online''. In that case try ''svcs -xv'' and check out the logfile.

====Stop your appserver====
 $ pfexec svcadm disable glassfish-gem:my-railsapp_production

====Restart your appserver====
 $ pfexec svcadm restart glassfish-gem:my-railsapp_production



===Apache 2.2 Frontend=== 

On OpenSolaris you can install Apache 2.2 with IPS:

 # pkg install SUNWapch22

On Ubuntu/Debian Linux, you would use apt: (TODO: verify package name on Ubuntu/Debian)
 
# aptitude install apache2.2

This example commands also refer to Solaris. You configure Apache 2.2. the same way in other OSes, but paths to configurations may vary. For instance on Debian/Ubuntu, apache config files are placed in ''/etc/apache2/sites-available/MY-CONFIG-FILE'' and these are enabled by a symlink in ''/etc/apache2/sites-enabled'' to the config file.

File ''/etc/apache2/2.2/sites/myrailsapp.jruby.org''

 <VirtualHost *:80>

 ServerName myrailsapp.jruby.org
 DocumentRoot /var/apps/my-railsapp/production/my-railsapp/public
 <Directory /var/apps/my-railsapp/production/my-railsapp/public>
  Options FollowSymLinks
  AllowOverride All
  Order allow,deny
  Allow from all
 </Directory>
 <Proxy balancer://myrailsapp>
  BalancerMember http://127.0.0.1:3000
 </Proxy>

 ProxyPass / balancer://myrailsapp/
 CustomLog /var/log/apache2/myrailsapp_production_apache_access_log combined

 </VirtualHost>

Since I place my virtual hosts in separate files, I need to add include to these at the bottom of the main configuration file ''/etc/apache2/2.2/httpd.conf''. If you haven't already configured your Apache server to use Virtual Hosts, you may have to add NameVirtualHost to your configuration:

 NameVirtualHost *:80
 Include /etc/apache2/2.2/sites/*

Now just enable (or restart your apache 2.2 server) 
 $ pfexec svcadm enable apache22 
 $ pfexec svcadm restart apache22

TODO: Nginx frontend, Linux init.rd start/stop script. Formatting